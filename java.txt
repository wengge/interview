1.线程池
2.java并法包
3.设计模式
4.类加载的几种方式
5.ThreadLocal和内存泄露
6.


中间件：
1.怎么保证幂等性
2.消息丢失，重发怎么处理
3.技术选型rocketMq，kafka,activeMq
为什么使用消息队列？
使用消息队列有什么缺点?
消息队列如何选型?
如何保证消息队列是高可用的？
如何保证消息不被重复消费?
如何保证消费的可靠性传输?
如何保证消息的顺序性？
https://blog.csdn.net/smallspot/article/details/105650948

es:
1.为什么用es


1.synchronized 锁膨胀过程 底层原理
https://ddnd.cn/2019/03/21/java-synchronized/
https://blog.csdn.net/xueba8/article/details/88753443

特性：
synchronized的特性
1.可见性(内存屏障来实现的，和volatile相似),有序性,原子性

内存模型

2.volatile关键字解析

那么关键字volatie是如何做到的呢？volatie规定了上述8个操作的规则

只有当线程对变量执行的前一个操作是load时，线程才能对变量执行use操作；只有线程的后一个操作是use时，线程才能对变量执行load操作。即规定了use、load、read三个操作之间的约束关系，规定这三个操作必须连续的出现，保证了线程每次读取变量的值前都必须去主存获取最新的值。
只有当前程对变量执行的前一个操作是assign时，线程才能对变量执行store操作；只有线程的后一个操作是store时，线程才能对变量执行assign操作，即规定了assign、store、write三个操作之间的约束关系，规定了这三个操作必须连续的出现，保证线程每次修改变量后都必须将变量的值写回主存。
volatile的这两个规则，也正是保证了共享变量的可见性。

volatile变量通过插入内存屏障禁止了处理器重排序，从而解决了多线程环境下处理器重排序的问题。



CAS的优缺点

事务：
1.特性：原子型,一致性,隔离性，持久性
2.隔离级别：读未提交，读已提交，可重复读，可序列化
3.问题：脏读，不可重复读，幻读
4.spring中7种传播行为：
5.spring种事务失效的原因
6.声明式事务和编程式事务


设计模式：
代理模式，策略模式
https://segmentfault.com/a/1190000040094544

三个代理，静态代理，动态代理(jdk动态代理，cglib动态代理)
jdk代理接口，通过反射实现
cglib代理类，通过